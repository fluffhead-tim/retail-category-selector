# Aider Coding Conventions

# AI Coding Assistant Rules

You are an expert software developer assistant. Follow these comprehensive guidelines when helping with code:

## Project Context
- Primary frontend framework: none
- Meta-framework: none
- Backend framework: python-flask
- Primary language: python
- Styling: tailwind

# Python Development Rules

## Code Style & Formatting
- Follow PEP 8 style guide
- Use Black for automatic code formatting (88 char line length)
- Use isort for import sorting (black compatible settings)
- Use flake8 or ruff for linting
- Follow naming conventions:
  - `snake_case` for functions, variables, modules
  - `PascalCase` for classes
  - `UPPER_SNAKE_CASE` for constants
  - Private with single underscore `_private`
  - Name mangling with double underscore `__very_private`

## Project Structure
```
project/
├── src/
│   └── package_name/
│       ├── __init__.py
│       ├── core/
│       ├── api/
│       ├── models/
│       └── utils/
├── tests/
│   ├── unit/
│   ├── integration/
│   └── fixtures/
├── docs/
├── scripts/
├── requirements/
│   ├── base.txt
│   ├── dev.txt
│   └── prod.txt
├── .env.example
├── pyproject.toml
└── README.md
```

## Type Hints & Annotations
- Use type hints for all function signatures
- Import from `typing` module for complex types
- Use `Optional[T]` over `T | None` for clarity
- Define custom types with TypeAlias
- Use Protocol for structural subtyping
- Type hint generators and async functions
- Use TypedDict for dictionary structures
- Run mypy for static type checking

## Error Handling
- Use specific exception types
- Create custom exceptions for domain errors
- Always catch specific exceptions, not bare except
- Use finally for cleanup operations
- Log exceptions with proper context
- Re-raise with `raise` to preserve stack trace
- Use contextlib for resource management
- Handle errors at appropriate levels

## Functions & Classes
- Keep functions small and focused
- Use descriptive names
- Document with docstrings (Google/NumPy style)
- Avoid mutable default arguments
- Use *args and **kwargs judiciously
- Implement `__str__` and `__repr__` for classes
- Use properties for computed attributes
- Follow SOLID principles

## Async Programming
- Use async/await for I/O operations
- Avoid blocking operations in async functions
- Use asyncio.gather for concurrent operations
- Implement proper error handling in async code
- Use async context managers
- Avoid mixing sync and async code
- Use proper async libraries (httpx, aiofiles)
- Test async code properly

## Testing Best Practices
- Use pytest as testing framework
- Write tests before or with code (TDD)
- Aim for high test coverage (>80%)
- Use fixtures for test data
- Mock external dependencies
- Test edge cases and error conditions
- Use parameterized tests
- Keep tests independent and fast

## Documentation
- Use docstrings for all public modules, functions, classes
- Follow Google or NumPy docstring style consistently
- Include type information in docstrings
- Document parameters, returns, raises
- Keep README.md comprehensive and updated
- Use inline comments sparingly and meaningfully
- Generate API docs with Sphinx or mkdocs
- Include usage examples

## Virtual Environments & Dependencies
- Always use virtual environments (venv, virtualenv, poetry)
- Pin dependency versions in requirements files
- Separate dev and production dependencies
- Use pip-tools or poetry for dependency management
- Regular security updates with pip-audit
- Document system dependencies
- Use .env files for configuration
- Never commit sensitive data

## Performance Optimization
- Profile before optimizing
- Use appropriate data structures
- Leverage built-in functions and libraries
- Use generators for memory efficiency
- Implement caching where appropriate
- Use concurrent.futures for CPU-bound tasks
- Use asyncio for I/O-bound tasks
- Monitor memory usage

## Security Best Practices
- Never hardcode secrets or passwords
- Use environment variables for config
- Validate and sanitize all inputs
- Use parameterized queries for databases
- Keep dependencies updated
- Use cryptography library for encryption
- Implement proper authentication
- Follow OWASP guidelines

## Logging & Monitoring
- Use Python's logging module
- Configure appropriate log levels
- Use structured logging (JSON)
- Include context in log messages
- Rotate logs appropriately
- Don't log sensitive information
- Use correlation IDs for tracing
- Monitor application metrics

## Database Best Practices
- Use ORM for database interactions (SQLAlchemy)
- Implement proper migrations (Alembic)
- Use connection pooling
- Handle transactions properly
- Implement proper indexing
- Use prepared statements
- Avoid N+1 queries
- Back up data regularly

## API Development (General)
- Follow RESTful principles
- Use proper HTTP methods and status codes
- Implement pagination for lists
- Version your APIs
- Use proper authentication (JWT, OAuth)
- Implement rate limiting
- Validate request data
- Return consistent response formats

## Code Quality Tools
- pre-commit hooks for formatting and linting
- GitHub Actions or GitLab CI for automation
- Coverage.py for test coverage
- Bandit for security scanning
- Black for formatting
- isort for import sorting
- mypy for type checking
- pytest for testing

## Best Practices Summary
- Write readable code - code is read more than written
- Follow the Zen of Python (import this)
- Don't repeat yourself (DRY)
- Keep it simple (KISS)
- You aren't gonna need it (YAGNI)
- Fail fast and explicitly
- Use standard library when possible
- Contribute back to open source

# Tailwind CSS Development Rules

## Configuration & Setup
- Configure content paths properly in `tailwind.config.js`
- Extend theme instead of replacing defaults
- Use CSS variables for dynamic theming
- Configure proper purge/content for production builds
- Set up PostCSS with autoprefixer
- Use @tailwind directives in main CSS file
- Configure custom breakpoints thoughtfully
- Set up proper IDE intellisense support

## Utility-First Principles
- Prefer utility classes over custom CSS
- Use @apply sparingly - only for repeated patterns
- Avoid premature abstraction into components
- Keep utility classes in template files
- Use arbitrary values [size] only when necessary
- Leverage Tailwind's modifier system
- Compose utilities for complex designs
- Maintain readability with logical grouping

## Responsive Design
- Use mobile-first approach (unprefixed, then sm:, md:, lg:, xl:)
- Define breakpoints based on content, not devices
- Use container with responsive padding
- Implement responsive typography scales
- Handle images responsively with aspect-ratio
- Use responsive grid and flexbox layouts
- Test across all defined breakpoints
- Consider using container queries when supported

## Color System
- Use semantic color naming (primary, secondary, danger, etc.)
- Leverage Tailwind's color palette
- Implement proper color contrast for accessibility
- Use color opacity modifiers (bg-blue-500/50)
- Create consistent hover/focus states
- Implement dark mode with dark: modifier
- Use CSS variables for dynamic themes
- Maintain WCAG color contrast standards

## Typography
- Use Tailwind's typography scale consistently
- Implement responsive font sizes
- Set proper line heights for readability
- Use font weight utilities appropriately
- Configure custom fonts in extend.fontFamily
- Apply prose class for content-heavy sections
- Use text utilities for alignment and decoration
- Implement proper text contrast ratios

## Spacing & Layout
- Use Tailwind's spacing scale consistently
- Prefer padding over margin for component internals
- Use negative margins sparingly
- Implement consistent spacing patterns
- Use space-x/y utilities for child element spacing
- Leverage gap utilities in flex/grid containers
- Use divide utilities for borders between elements
- Maintain vertical rhythm throughout

## Flexbox & Grid
- Use flex utilities for one-dimensional layouts
- Use grid for two-dimensional layouts
- Implement proper alignment with justify/items/content
- Use flex-wrap for responsive layouts
- Leverage grid template areas for complex layouts
- Use auto-fit/auto-fill for responsive grids
- Implement proper gap spacing
- Consider CSS Grid for card layouts

## Component Patterns
- Create consistent button variants
- Implement card components with proper shadows
- Use ring utilities for focus states
- Create reusable form input styles
- Implement modal/dialog patterns
- Use group hover for interactive elements
- Create loading states with animation utilities
- Build navigation with proper active states

## State Variants
- Use hover: for mouse interactions
- Implement focus: for keyboard navigation
- Use active: for click states
- Leverage disabled: for inactive elements
- Implement group-hover: for parent interactions
- Use peer modifiers for sibling styling
- Handle checked: states for checkboxes/radios
- Implement visited: for links appropriately

## Dark Mode
- Design with dark mode in mind from start
- Use dark: modifier for dark mode styles
- Implement proper color contrast in dark mode
- Consider using class-based dark mode
- Test all components in both modes
- Use semantic colors that work in both modes
- Handle images and icons for dark mode
- Implement smooth transitions between modes

## Animations & Transitions
- Use transition utilities for smooth interactions
- Implement animation utilities appropriately
- Create custom animations in config when needed
- Use transform utilities for movement
- Implement proper easing functions
- Consider reduced motion preferences
- Use animation delays sparingly
- Keep animations performant

## Forms & Inputs
- Style form elements consistently
- Use ring utilities for focus indicators
- Implement proper error states
- Create consistent input sizes
- Style select elements appropriately
- Handle placeholder styling
- Implement proper label positioning
- Use peer utilities for validation states

## Performance Optimization
- Configure PurgeCSS/JIT properly
- Avoid generating unused utilities
- Use production builds for deployment
- Monitor CSS bundle size
- Implement critical CSS when needed
- Use CDN for faster delivery
- Minimize custom CSS additions
- Leverage browser caching

## Accessibility
- Ensure proper color contrast ratios
- Use semantic HTML with utilities
- Implement focus-visible states
- Provide sr-only text when needed
- Test with keyboard navigation
- Use ARIA attributes when necessary
- Implement proper heading hierarchy
- Consider screen reader users

## Best Practices
- Group utilities logically (layout, typography, colors)
- Use consistent ordering of utilities
- Extract components for truly reusable patterns
- Comment complex utility combinations
- Use Prettier plugin for class sorting
- Maintain consistent naming conventions
- Document custom utilities and plugins
- Keep configuration changes minimal

## Component Libraries
- Integrate with shadcn/ui components
- Customize component library themes
- Override default styles carefully
- Maintain design system consistency
- Use CVA for component variants
- Implement proper component APIs
- Document component usage
- Test components across browsers

## Development Best Practices

# Clean Code Development Rules

## Naming Conventions
- Use meaningful and pronounceable variable names
- Use searchable names (avoid single letters or numeric constants)
- Avoid mental mapping - be explicit
- Class names should be nouns (Customer, Account)
- Method names should be verbs (getName, calculateTotal)
- Use consistent naming throughout the codebase
- Avoid abbreviations unless universally understood
- Use intention-revealing names

## Functions & Methods
- Functions should do one thing only
- Keep functions small (ideally < 20 lines)
- Use descriptive function names
- Limit function parameters (ideally ≤ 3)
- Functions should have no side effects
- Use pure functions when possible
- Extract complex conditionals into functions
- Avoid flag arguments - split into multiple functions

## Code Organization
- Keep related functionality close together
- Organize code from high level to low level
- Group similar functions
- Maintain consistent file structure
- Use meaningful file and folder names
- Keep files focused and small
- Separate concerns appropriately
- Follow established patterns in the codebase

## Comments & Documentation
- Code should be self-documenting
- Use comments to explain "why," not "what"
- Keep comments up-to-date with code changes
- Remove commented-out code
- Document complex algorithms
- Write meaningful commit messages
- Document APIs and public interfaces
- Avoid redundant comments

## Error Handling
- Use exceptions rather than error codes
- Create meaningful error messages
- Handle errors at the appropriate level
- Don't ignore or suppress errors
- Log errors with context
- Fail fast when appropriate
- Use custom exceptions for domain errors
- Clean up resources in finally blocks

## Code Simplicity
- Avoid clever code - write obvious code
- Reduce cyclomatic complexity
- Eliminate dead code
- Avoid premature optimization
- Extract magic numbers to constants
- Use early returns to reduce nesting
- Simplify conditional expressions
- Remove unnecessary complexity

## DRY Principle
- Don't Repeat Yourself
- Extract common code into functions
- Create reusable components
- Use configuration over duplication
- Centralize business rules
- Avoid copy-paste programming
- Maintain single source of truth
- Balance DRY with readability

## SOLID Principles
- **Single Responsibility**: Classes should have one reason to change
- **Open/Closed**: Open for extension, closed for modification
- **Liskov Substitution**: Derived classes must be substitutable
- **Interface Segregation**: Many specific interfaces are better
- **Dependency Inversion**: Depend on abstractions, not concretions

## Testing Principles
- Write tests first (TDD when appropriate)
- Keep tests simple and focused
- Use descriptive test names
- Test one concept per test
- Keep tests independent
- Use meaningful test data
- Maintain test code quality
- Aim for high coverage of critical paths

## Refactoring Guidelines
- Refactor in small steps
- Run tests after each change
- Keep refactoring separate from features
- Remove duplication
- Improve names
- Simplify conditionals
- Extract methods and classes
- Leave code better than you found it

## Performance Considerations
- Measure before optimizing
- Optimize algorithms before code
- Consider space-time tradeoffs
- Cache expensive operations
- Use appropriate data structures
- Avoid premature optimization
- Profile to find bottlenecks
- Document performance decisions

## Code Reviews
- Review code regularly
- Focus on correctness first
- Check for maintainability
- Ensure consistent style
- Look for potential bugs
- Verify test coverage
- Provide constructive feedback
- Learn from reviews

## Version Control
- Make small, focused commits
- Write clear commit messages
- Use branching strategies effectively
- Keep main/master branch stable
- Review before merging
- Tag releases appropriately
- Document breaking changes
- Maintain clean history

## Security Practices
- Validate all inputs
- Sanitize user data
- Use parameterized queries
- Don't store sensitive data in code
- Keep dependencies updated
- Follow principle of least privilege
- Implement proper authentication
- Log security events

## Team Practices
- Follow team conventions
- Communicate design decisions
- Document architectural choices
- Share knowledge regularly
- Pair program complex features
- Maintain coding standards
- Use linters and formatters
- Automate repetitive tasks

## Continuous Improvement
- Learn from mistakes
- Stay updated with best practices
- Refactor legacy code gradually
- Measure code quality metrics
- Address technical debt
- Experiment with new approaches
- Share learnings with team
- Maintain a growth mindset

# Git Workflow & Version Control Rules

## Gitflow Workflow

### Main Branches
- **main/master**: Production-ready code only
  - Never commit directly
  - Only merge from release/* and hotfix/*
  - Tag with version after each merge
  - Protected branch with strict rules

- **develop**: Integration branch for features
  - Latest development changes
  - Source for feature branches
  - Never commit directly
  - Merge feature branches here

### Supporting Branches
- **feature/***: New features
  - Branch from: develop
  - Merge to: develop
  - Naming: `feature/[issue-id]-description`
  - Example: `feature/123-user-authentication`
  - Delete after merge

- **release/***: Prepare production releases
  - Branch from: develop
  - Merge to: main AND develop
  - Naming: `release/vX.Y.Z`
  - Only fixes and release tasks
  - No new features

- **hotfix/***: Emergency production fixes
  - Branch from: main
  - Merge to: main AND develop
  - Naming: `hotfix/vX.Y.Z`
  - Urgent fixes only
  - Delete after merge

## Commit Message Convention

### Format
```
type(scope): subject

[optional body]

[optional footer(s)]
```

### Types
- **feat**: New feature
- **fix**: Bug fix
- **docs**: Documentation only
- **style**: Formatting (no code change)
- **refactor**: Code restructuring
- **perf**: Performance improvements
- **test**: Adding/updating tests
- **build**: Build system changes
- **ci**: CI configuration changes
- **chore**: Other changes
- **revert**: Revert previous commit

### Examples
```
feat(auth): add OAuth2 integration

fix(api): handle null response in user endpoint

docs(readme): update installation instructions

refactor(utils): simplify date formatting logic
```

## Semantic Versioning
- **MAJOR** (X.0.0): Breaking changes
- **MINOR** (0.X.0): New features (backward compatible)
- **PATCH** (0.0.X): Bug fixes (backward compatible)
- Pre-release: X.Y.Z-alpha.1, X.Y.Z-beta.2
- Build metadata: X.Y.Z+20130313144700

## Branch Protection Rules
- Require pull request reviews (min 1-2)
- Require status checks to pass
- Require branches to be up to date
- Dismiss stale reviews
- Require code owner reviews
- No force pushes allowed
- No branch deletion
- Include administrators

## Pull Request Guidelines

### Before Creating PR
- Update branch with latest develop/main
- Run all tests locally
- Check code formatting
- Update documentation
- Self-review changes
- Ensure single logical change

### PR Description Template
```markdown
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
- [ ] No console.logs or debug code
```

### Code Review Process
- Respond to feedback promptly
- Keep discussions professional
- Focus on code, not person
- Suggest improvements
- Approve when satisfied
- Squash commits if needed

## Git Best Practices

### Committing
- Commit early and often
- Make atomic commits
- Write meaningful messages
- Don't commit broken code
- Avoid large binary files
- Use .gitignore properly
- Sign commits when required
- Keep history clean

### Branching
- Keep branches short-lived
- One feature per branch
- Update frequently from base
- Use descriptive names
- Clean up old branches
- Avoid deep branch nesting
- Test before merging
- Use fast-forward when possible

### Merging Strategies
- **Feature → Develop**: Squash and merge
- **Release → Main**: Create merge commit
- **Hotfix → Main**: Create merge commit
- **Back-merges**: Create merge commit
- Resolve conflicts carefully
- Test after merging
- Update related issues
- Notify team of major merges

## Release Process
1. Create release branch from develop
2. Update version numbers
3. Update changelog
4. Fix release-specific issues
5. Create PR to main
6. Get required approvals
7. Merge to main
8. Tag release with version
9. Create GitHub release
10. Merge back to develop
11. Delete release branch
12. Deploy to production

## Hotfix Process
1. Create hotfix branch from main
2. Fix critical issue
3. Update patch version
4. Test thoroughly
5. Create PR to main
6. Get emergency approval
7. Merge to main
8. Tag hotfix version
9. Deploy immediately
10. Merge back to develop
11. Delete hotfix branch
12. Document incident

## Git Commands Reference

### Daily Workflow
```bash
git fetch origin
git checkout -b feature/new-feature origin/develop
git add -p  # Stage changes interactively
git commit -m "feat: add new feature"
git push -u origin feature/new-feature
```

### Keeping Updated
```bash
git checkout develop
git pull origin develop
git checkout feature/branch
git rebase develop  # or merge
```

### Cleaning Up
```bash
git branch -d feature/completed
git remote prune origin
git gc --aggressive
```

## Team Conventions
- Agree on workflow rules
- Document exceptions
- Use consistent naming
- Automate where possible
- Regular branch cleanup
- Monitor repo health
- Train new members
- Review and adapt process

# Error Handling Best Practices

## Error Types and Strategies

### Error Categories
- **Operational Errors**: Expected errors (network failures, invalid input)
- **Programming Errors**: Bugs in code (type errors, logic errors)
- **System Errors**: Infrastructure issues (out of memory, disk full)

## Frontend Error Handling

### Try-Catch Blocks
```javascript
async function fetchData() {
  try {
    const response = await api.getData();
    return response.data;
  } catch (error) {
    // Log error for debugging
    console.error('Data fetch failed:', error);
    
    // Handle specific error types
    if (error.code === 'NETWORK_ERROR') {
      throw new Error('Network connection failed. Please try again.');
    }
    
    // Re-throw unknown errors
    throw error;
  }
}
```

### Error Boundaries (React)
```javascript
class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null };
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    // Log to error reporting service
    errorReportingService.log({ error, errorInfo });
  }
  
  render() {
    if (this.state.hasError) {
      return <ErrorFallback error={this.state.error} />;
    }
    return this.props.children;
  }
}
```

### Global Error Handlers
```javascript
// Unhandled promise rejections
window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  event.preventDefault();
});

// Global error handler
window.addEventListener('error', (event) => {
  console.error('Global error:', event.error);
});
```

## Backend Error Handling

### Express Error Middleware
```javascript
// Custom error class
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;
  }
}

// Error handling middleware
app.use((err, req, res, next) => {
  const { statusCode = 500, message } = err;
  
  // Log error
  logger.error({
    error: err,
    request: req.url,
    method: req.method,
  });
  
  res.status(statusCode).json({
    status: 'error',
    message: statusCode === 500 ? 'Internal server error' : message,
  });
});
```

### Async Route Handler
```javascript
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

app.get('/users/:id', asyncHandler(async (req, res) => {
  const user = await User.findById(req.params.id);
  if (!user) {
    throw new AppError('User not found', 404);
  }
  res.json(user);
}));
```

## Validation and Input Errors

### Schema Validation
```javascript
const { body, validationResult } = require('express-validator');

const validateUser = [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 8 }),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    next();
  }
];
```

### Frontend Validation
```javascript
function validateForm(data) {
  const errors = {};
  
  if (!data.email || !isValidEmail(data.email)) {
    errors.email = 'Valid email is required';
  }
  
  if (!data.password || data.password.length < 8) {
    errors.password = 'Password must be at least 8 characters';
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors,
  };
}
```

## Error Recovery Strategies

### Retry Logic
```javascript
async function fetchWithRetry(url, options = {}, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url, options);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      return response;
    } catch (error) {
      if (i === retries - 1) throw error;
      
      // Exponential backoff
      await new Promise(resolve => 
        setTimeout(resolve, Math.pow(2, i) * 1000)
      );
    }
  }
}
```

### Circuit Breaker Pattern
```javascript
class CircuitBreaker {
  constructor(fn, threshold = 5, timeout = 60000) {
    this.fn = fn;
    this.threshold = threshold;
    this.timeout = timeout;
    this.failures = 0;
    this.nextAttempt = Date.now();
  }
  
  async call(...args) {
    if (this.failures >= this.threshold) {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.failures = 0;
    }
    
    try {
      const result = await this.fn(...args);
      this.failures = 0;
      return result;
    } catch (error) {
      this.failures++;
      if (this.failures >= this.threshold) {
        this.nextAttempt = Date.now() + this.timeout;
      }
      throw error;
    }
  }
}
```

## User-Friendly Error Messages

### Error Message Guidelines
- Be specific but not technical
- Provide actionable solutions
- Maintain consistent tone
- Include error codes for support

### Error Display Component
```javascript
const ErrorMessage = ({ error, onRetry }) => {
  const getMessage = (error) => {
    const messages = {
      NETWORK_ERROR: 'Connection failed. Please check your internet.',
      AUTH_FAILED: 'Login failed. Please check your credentials.',
      NOT_FOUND: 'The requested resource was not found.',
      DEFAULT: 'Something went wrong. Please try again.',
    };
    
    return messages[error.code] || messages.DEFAULT;
  };
  
  return (
    <div className="error-container">
      <p>{getMessage(error)}</p>
      {onRetry && (
        <button onClick={onRetry}>Try Again</button>
      )}
    </div>
  );
};
```

## Logging and Monitoring

### Structured Logging
```javascript
const logger = winston.createLogger({
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

// Log with context
logger.error('Database query failed', {
  query: 'SELECT * FROM users',
  error: error.message,
  stack: error.stack,
  userId: req.user?.id,
  timestamp: new Date().toISOString(),
});
```

### Error Tracking Services
```javascript
// Sentry integration
Sentry.init({ dsn: process.env.SENTRY_DSN });

// Capture exceptions
try {
  riskyOperation();
} catch (error) {
  Sentry.captureException(error, {
    tags: { section: 'payment' },
    extra: { orderId: order.id },
  });
}
```

## Best Practices Summary

### Do's
- ✅ Handle errors at appropriate levels
- ✅ Provide meaningful error messages
- ✅ Log errors with context
- ✅ Implement retry mechanisms
- ✅ Use error boundaries in React
- ✅ Validate input early

### Don'ts
- ❌ Don't expose sensitive information
- ❌ Avoid catching errors without handling
- ❌ Don't use generic error messages
- ❌ Avoid infinite retry loops
- ❌ Don't ignore error logs

# Performance Optimization

## Core Web Vitals

### Metrics to Track
- **LCP** (Largest Contentful Paint): < 2.5s
- **FID** (First Input Delay): < 100ms
- **CLS** (Cumulative Layout Shift): < 0.1
- **FCP** (First Contentful Paint): < 1.8s
- **TTFB** (Time to First Byte): < 600ms

## Frontend Performance

### JavaScript Optimization
```javascript
// Code splitting
const HeavyComponent = lazy(() => import('./HeavyComponent'));

// Tree shaking
export { specificFunction } from './utils'; // Not export *

// Bundle optimization
// webpack.config.js
optimization: {
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      vendor: {
        test: /[\\/]node_modules[\\/]/,
        priority: 10
      }
    }
  }
}
```

### CSS Optimization
```css
/* Critical CSS inline */
<style>
  /* Above-the-fold styles */
  .hero { /* ... */ }
</style>

/* Non-critical CSS deferred */
<link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
```

### Image Optimization
```html
<!-- Modern formats with fallback -->
<picture>
  <source srcset="image.webp" type="image/webp">
  <source srcset="image.jpg" type="image/jpeg">
  <img src="image.jpg" alt="Description" loading="lazy">
</picture>

<!-- Responsive images -->
<img srcset="small.jpg 480w, medium.jpg 800w, large.jpg 1200w"
     sizes="(max-width: 600px) 480px, (max-width: 900px) 800px, 1200px"
     src="medium.jpg" alt="Description">
```

### Resource Loading
```html
<!-- Preconnect to external domains -->
<link rel="preconnect" href="https://fonts.googleapis.com">

<!-- Preload critical resources -->
<link rel="preload" href="/font.woff2" as="font" type="font/woff2" crossorigin>

<!-- DNS prefetch -->
<link rel="dns-prefetch" href="//api.example.com">
```

## React Performance

### Component Optimization
```javascript
// Memoization
const ExpensiveComponent = memo(({ data }) => {
  return <div>{/* Expensive render */}</div>;
});

// useMemo for expensive computations
const sortedList = useMemo(
  () => list.sort((a, b) => b.value - a.value),
  [list]
);

// useCallback for stable references
const handleClick = useCallback((id) => {
  setSelected(id);
}, []);

// React 18 features
const [isPending, startTransition] = useTransition();
startTransition(() => {
  setSearchQuery(input);
});
```

### Virtual Lists
```javascript
import { FixedSizeList } from 'react-window';

<FixedSizeList
  height={600}
  itemCount={items.length}
  itemSize={50}
  width="100%"
>
  {({ index, style }) => (
    <div style={style}>{items[index].name}</div>
  )}
</FixedSizeList>
```

## Backend Performance

### Database Optimization
```sql
-- Indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_created ON orders(user_id, created_at DESC);

-- Query optimization
-- Bad
SELECT * FROM users WHERE YEAR(created_at) = 2023;

-- Good
SELECT id, name, email FROM users 
WHERE created_at >= '2023-01-01' AND created_at < '2024-01-01';

-- Use EXPLAIN
EXPLAIN ANALYZE SELECT ...
```

### Caching Strategies
```javascript
// Memory cache (Node.js)
const cache = new Map();

function getCachedData(key) {
  if (cache.has(key)) {
    const { data, timestamp } = cache.get(key);
    if (Date.now() - timestamp < 3600000) { // 1 hour
      return data;
    }
  }
  return null;
}

// Redis cache
const redis = require('redis');
const client = redis.createClient();

async function getCached(key) {
  const cached = await client.get(key);
  return cached ? JSON.parse(cached) : null;
}

// HTTP cache headers
res.setHeader('Cache-Control', 'public, max-age=3600');
res.setHeader('ETag', etag);
```

### API Optimization
```javascript
// Pagination
app.get('/api/users', async (req, res) => {
  const { page = 1, limit = 20 } = req.query;
  const offset = (page - 1) * limit;
  
  const users = await db.users.findMany({
    skip: offset,
    take: limit,
    select: { id: true, name: true, email: true }
  });
  
  res.json({ data: users, page, limit });
});

// Field selection
app.get('/api/users/:id', async (req, res) => {
  const fields = req.query.fields?.split(',') || ['id', 'name', 'email'];
  const user = await db.users.findUnique({
    where: { id: req.params.id },
    select: fields.reduce((acc, field) => ({ ...acc, [field]: true }), {})
  });
  res.json(user);
});
```

## Build Optimization

### Webpack Configuration
```javascript
module.exports = {
  optimization: {
    minimize: true,
    sideEffects: false,
    usedExports: true,
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        default: false,
        vendors: false,
        vendor: {
          name: 'vendor',
          chunks: 'all',
          test: /node_modules/
        }
      }
    }
  }
};
```

### Bundle Analysis
```bash
# Webpack Bundle Analyzer
npm install --save-dev webpack-bundle-analyzer

# In webpack.config.js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
plugins: [new BundleAnalyzerPlugin()]

# Vite
npm install --save-dev rollup-plugin-visualizer
```

## Monitoring

### Performance API
```javascript
// Measure component render time
const measure = (name, fn) => {
  performance.mark(`${name}-start`);
  const result = fn();
  performance.mark(`${name}-end`);
  performance.measure(name, `${name}-start`, `${name}-end`);
  
  const measure = performance.getEntriesByName(name)[0];
  console.log(`${name} took ${measure.duration}ms`);
  return result;
};

// Observer pattern
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    console.log(`${entry.name}: ${entry.duration}ms`);
  });
});
observer.observe({ entryTypes: ['measure'] });
```

## Best Practices

### Do's
- ✅ Measure before optimizing
- ✅ Set performance budgets
- ✅ Use lazy loading
- ✅ Optimize critical rendering path
- ✅ Implement caching strategies
- ✅ Monitor real user metrics

### Don'ts
- ❌ Don't optimize prematurely
- ❌ Avoid blocking the main thread
- ❌ Don't ignore mobile performance
- ❌ Avoid memory leaks
- ❌ Don't serve unoptimized images

### Quick Wins
1. Enable gzip/brotli compression
2. Minify CSS/JS/HTML
3. Use CDN for static assets
4. Implement browser caching
5. Optimize images
6. Remove unused code
7. Defer non-critical scripts
8. Preconnect to required origins

# Security Development Rules

## Authentication Best Practices

### Password Security
- Use bcrypt, scrypt, or Argon2 for hashing
- Implement proper salt rounds (min 10 for bcrypt)
- Never store plain text passwords
- Enforce strong password policies
- Implement password history
- Use secure password reset flows
- Rate limit login attempts
- Implement account lockout mechanisms

### Multi-Factor Authentication (MFA)
- Support TOTP (Time-based One-Time Password)
- Implement backup codes
- Use SMS as last resort (SIM swapping risk)
- Support hardware tokens (FIDO2/WebAuthn)
- Provide recovery mechanisms
- Log MFA events
- Allow users to manage devices
- Implement risk-based authentication

### Session Management
- Use secure, httpOnly, sameSite cookies
- Implement proper session expiration
- Regenerate session IDs after login
- Invalidate sessions on logout
- Implement idle timeout
- Use secure session storage
- Monitor concurrent sessions
- Implement "remember me" securely

### JWT Best Practices
- Use short expiration times
- Implement refresh token rotation
- Store sensitive data server-side
- Use strong signing algorithms (RS256)
- Validate all claims
- Implement proper revocation
- Don't store tokens in localStorage
- Use secure transmission only

## Authorization

### Access Control
- Implement least privilege principle
- Use Role-Based Access Control (RBAC)
- Consider Attribute-Based Access Control (ABAC)
- Validate permissions on every request
- Implement resource-level permissions
- Use policy-based authorization
- Audit authorization decisions
- Implement deny-by-default

### API Security
- Use API keys for service authentication
- Implement rate limiting per user/IP
- Use OAuth 2.0 for third-party access
- Validate all inputs
- Implement request signing
- Use API versioning
- Monitor API usage
- Implement circuit breakers

## Input Validation & Sanitization

### Validation Rules
- Validate on both client and server
- Use whitelist validation
- Check data types and ranges
- Validate file uploads thoroughly
- Limit input sizes
- Use parameterized queries
- Escape output based on context
- Implement content security policies

### SQL Injection Prevention
```sql
-- Never do this
query = "SELECT * FROM users WHERE id = " + userId

-- Always use parameterized queries
query = "SELECT * FROM users WHERE id = ?"
```

### XSS Prevention
- Escape HTML entities
- Use Content Security Policy (CSP)
- Validate URLs
- Sanitize rich text input
- Use templating engines with auto-escaping
- Avoid innerHTML with user data
- Implement strict MIME type checking
- Use X-Content-Type-Options header

## Secure Communication

### HTTPS/TLS
- Use TLS 1.2 minimum
- Implement HSTS (HTTP Strict Transport Security)
- Use secure cipher suites
- Implement certificate pinning for mobile
- Redirect HTTP to HTTPS
- Use secure cookies
- Implement OCSP stapling
- Regular certificate renewal

### Security Headers
```
Strict-Transport-Security: max-age=31536000; includeSubDomains
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
Content-Security-Policy: default-src 'self'
Referrer-Policy: strict-origin-when-cross-origin
Permissions-Policy: geolocation=(), microphone=()
```

## Data Protection

### Encryption at Rest
- Encrypt sensitive data in database
- Use field-level encryption when needed
- Implement key rotation
- Use hardware security modules (HSM)
- Encrypt backups
- Secure key storage
- Implement data masking
- Use transparent data encryption

### Encryption in Transit
- Use TLS for all communications
- Implement end-to-end encryption for sensitive data
- Use VPN for internal communications
- Encrypt API payloads when necessary
- Implement message-level security
- Use secure protocols only
- Monitor for protocol downgrades
- Implement perfect forward secrecy

### Personal Data Protection (GDPR/CCPA)
- Implement data minimization
- Provide data portability
- Implement right to deletion
- Maintain audit logs
- Get explicit consent
- Implement privacy by design
- Regular privacy assessments
- Document data processing

## Infrastructure Security

### Container Security
```dockerfile
# Run as non-root user
FROM node:alpine
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001
USER nodejs

# Copy only necessary files
COPY --chown=nodejs:nodejs . .
```

### Kubernetes Security
```yaml
apiVersion: v1
kind: Pod
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 2000
  containers:
  - name: app
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
```

### Cloud Security
- Use IAM roles instead of keys
- Implement least privilege
- Enable cloud audit logs
- Use VPC and security groups
- Implement network segmentation
- Regular security assessments
- Use cloud-native security tools
- Implement defense in depth

## Security Monitoring

### Logging & Auditing
- Log authentication events
- Monitor authorization failures
- Track data access
- Log security exceptions
- Implement centralized logging
- Use structured logging
- Protect log integrity
- Regular log analysis

### Intrusion Detection
- Implement rate limiting
- Detect brute force attacks
- Monitor for SQL injection attempts
- Track unusual access patterns
- Use Web Application Firewall (WAF)
- Implement honeypots
- Regular security scans
- Incident response plan

### Security Testing
- Regular penetration testing
- Automated security scanning
- Dependency vulnerability scanning
- Static code analysis
- Dynamic application testing
- Security code reviews
- Bug bounty programs
- Red team exercises

## Secure Development Lifecycle

### Code Security
- Never hardcode secrets
- Use environment variables
- Implement secret rotation
- Regular dependency updates
- Security-focused code reviews
- Use security linters
- Implement git-secrets
- Secure CI/CD pipelines

### Third-Party Dependencies
- Regular vulnerability scanning
- Use lock files
- Monitor security advisories
- Implement Software Bill of Materials (SBOM)
- Vendor security assessment
- License compliance
- Supply chain security
- Regular updates

### Incident Response
- Incident response plan
- Security team contacts
- Escalation procedures
- Communication templates
- Post-mortem process
- Regular drills
- Lessons learned
- Continuous improvement

## OWASP Top 10 Prevention

1. **Injection**: Use parameterized queries
2. **Broken Authentication**: Implement secure session management
3. **Sensitive Data Exposure**: Encrypt sensitive data
4. **XML External Entities**: Disable XML external entity processing
5. **Broken Access Control**: Implement proper authorization
6. **Security Misconfiguration**: Harden all components
7. **XSS**: Validate and escape all inputs
8. **Insecure Deserialization**: Validate serialized objects
9. **Vulnerable Components**: Keep dependencies updated
10. **Insufficient Logging**: Implement comprehensive logging

## Security Best Practices Summary
- Security by design
- Defense in depth
- Least privilege principle
- Regular security updates
- Continuous monitoring
- Incident preparedness
- Security awareness training
- Regular security assessments